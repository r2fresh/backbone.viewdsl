{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Backbone.ViewDSL","body":"Backbone.ViewDSL is a tiny library which provides a DSL for defining\r\nBackbone.View hierarchies. If you are tired of manually composing views in your\r\nBackbone application and want to get rid of all accompanying boilerplate then\r\nthis library could help a bit.\r\n\r\nBackbone.ViewDSL provides a DSL built on top of HTML with the following\r\nfeatures:\r\n\r\n  * view instantiation (optionally loaded from AMD modules)\r\n\r\n  * conditional exclusion of DOM elements from a final result\r\n\r\n  * string and DOM node values interpolation\r\n\r\n## Installation\r\n\r\nYou can simply get\r\n[`backbone.viewdsl.js`](https://raw.github.com/andreypopp/backbone.viewdsl/master/backbone.viewdsl.js)\r\nfrom the repository or use the repository as a submodule in your project. In\r\nthat case you will need all the dependencies to be in place —\r\n[jQuery](http://jquery.com), [Backbone](http://http://backbonejs.org) and\r\n[RSVP.js](https://github.com/tildeio/rsvp.js).\r\n\r\nOtherwise you can use awesome [bower](http://twitter.github.com/bower/) package\r\nmanager and install Backbone.ViewDSL with:\r\n\r\n    bower install backbone.viewdsl\r\n\r\nThis way you will have Backbone.ViewDSL and all the dependencies installed under\r\n`./components` directory.\r\n\r\n## Usage\r\n\r\nBackbone.ViewDSL provides a view base class with additional methods to use DSL\r\nfor DOM rendering. There are two ways to use it — the first one is an ad-hoc\r\nview creation with a `from(template)` static method:\r\n\r\n    sidebarPromise = Backbone.ViewDSL.View.from \"\"\"\r\n      <div class=\"sidebar\">\r\n        <ul class=\"sidebar-items\">\r\n          <li class=\"sidebar-item\">...</li>\r\n          ...\r\n        </ul>\r\n      </div>\r\n      \"\"\"\r\n\r\nThis way you get a `sidebarPromise`, a promise value which will resolve\r\nasynchronously in the future. The reason it returns a promise is because\r\nrendering process may require to load some additional resources using XHR (such\r\nas additional view classes). You can execute some code with a constructed view\r\nby attaching `then` callback to the promise:\r\n\r\n    sidebarPromise.then (sidebar) ->\r\n      console.log \"View constructed: #{sidebar}\"\r\n\r\nNote that the `div.sidebar` will become the root element, the `el` of the view.\r\n\r\nStatic method `from(template)` accepts HTML strings, DOM elements or jQuery\r\nelements as a `template` argument.\r\n\r\nAnother way to use `Backbone.ViewDSL.View` is to subclass it and use\r\n`renderDOM(template, localContext)` method for rendering DOM:\r\n\r\n    class SidebarView extends Backbone.ViewDSL.View\r\n      tagName: \"div\"\r\n      className: \"sidebar\"\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <ul class=\"sidebar-items\">\r\n            <li class=\"sidebar-item\">...</li>\r\n            ...\r\n          </ul>\r\n          \"\"\"\r\n\r\nThis way `renderDOM` method will also return a promise but the one which\r\nresolves to DOM node which is rendered from template. First argument `template`\r\ncan be a HTML string, DOM element or jQuery element. As a second argument\r\n`renderDOM` accepts an object which provides \"local\" values to template context\r\nso actual context's prototype chain looks like `localContext -> this`.\r\n\r\n`Backbone.ViewDSL.View` also provides default implementation of\r\n`render(localContext)` method which renders DOM from a template provided by\r\ninstance or prototype-level `template` attribute. In the latter case of\r\n`template` attribute being attached to prototype — `render` method caches its\r\nDOM representation not to parse template more than once when rendering multiple\r\nview instances. So the easiest way to define view is:\r\n\r\n    class SidebarView extends Backbone.ViewDSL.View\r\n      tagName: \"div\"\r\n      className: \"sidebar\"\r\n      template: \"\"\"\r\n        <ul class=\"sidebar-items\">\r\n          <li class=\"sidebar-item\">...</li>\r\n          ...\r\n        </ul>\r\n        \"\"\"\r\n\r\n## View instantiation\r\n\r\nTo instantiate a view you can use `view` DOM attribute:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div view=\"myapp.views.SidebarView\" class=\"sidebar\"></div>\r\n          \"\"\"\r\n\r\nThis way `myapp.views.SidebarView` will be instantiated and rendered with `div.sidebar`\r\nelement as the view's root element. All instantiated views become the \"child\r\nviews\" of a parent view and stored inside a `views` attribute — that means on\r\nparent's `remove()` call they are also being freed by calling `remove()`.\r\n\r\nYou can also pass parameters to view constructor by using attributes which start\r\nwith `view-` prefix:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      initialize: ->\r\n        this.sidebar = new SidebarItems()\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div\r\n            view=\"myapp.views.SidebarView\"\r\n            view-collection=\"sidebar\"\r\n            view-style=\"vertical\"\r\n            class=\"sidebar\"></div>\r\n          \"\"\"\r\n\r\nThis will call a `myapp.views.SidebarView` constructor with `collection` and\r\n`style` arguments — the first one will be equal to `sidebar` attribute of the\r\n`MyView` instance, the second one — just a `\"vertical\"` string value. So this\r\nwill be equivalent to the following code:\r\n\r\n    class MyView extends Backbone.View\r\n\r\n      initialize: ->\r\n        this.sidebar = new SidebarItems()\r\n\r\n      render: ->\r\n        this.sidebarView = new myapp.views.SidebarView\r\n          className: 'sidebar'\r\n          collection: this.sidebar\r\n          style: 'vertical'\r\n        this.sidebarView.render()\r\n        this.$el.append(this.sidebarView.$el)\r\n\r\n      remove: ->\r\n        super\r\n        this.sidebarView.remove()\r\n\r\nNote that attributes those name contain more hyphens besides ones which are part\r\nof the prefix will be converted to camelCase so `view-some-param` becomes\r\n`someParam`.\r\n\r\nThere's also special attribute `view-id` — it instructs template processor to\r\nstore instantiated view in an attribute of the parent view. The `view-id` value\r\nbecomes the name of the attribute.\r\n\r\n## String and DOM node values interpolation\r\n\r\nYou can insert arbitrary strings, DOM nodes or jQuery elements into template:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      name: ->\r\n        $ '<span class=\"name\">World</span>'\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div class=\"hello\">\r\n            Hello, {{name}}!\r\n          </div>\r\n          \"\"\"\r\n\r\nThis will render a `Hello, <span class=\"name\">World</span>` string inside\r\n`div.hello` element. Note that you can also return just a raw string from\r\n`name()` method — it will be converted to DOM `TextNode`; otherwise you can\r\nreturn any DOM object.\r\n\r\n## Conditional exclusion\r\n\r\nTo remove DOM nodes conditionally you can use `if` DOM attribute:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      showConditional: ->\r\n        this.options.showConditional\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div class=\"conditional\" if=\"showConditional\">\r\n            ...\r\n          </div>\r\n          \"\"\"\r\n\r\nElement `div.conditional` will be removed if `showConditional()` method evaluates\r\nto `false`. Note that you can also refer to view properties and not only methods\r\ninside `if` attributes.\r\n\r\n## Specs\r\n\r\nSpecs are strings which point to JS objects, specs can point to some global\r\nobject or to some object inside AMD module:\r\n\r\n  * `module1/module2:obj1.obj2` points to `obj2` inside `obj1` in\r\n    `module1/module2` AMD module.\r\n\r\n  * `obj1.obj2` points to `obj2` inside `obj1` inside `window` object\r\n","tagline":"DSL for defining Backbone.View hierarchies","google":""}