{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Backbone.ViewDSL is a tiny library which provides a DSL for defining\r\nBackbone.View hierarchies. If you are tired of manually composing views in your\r\nBackbone application and want to get rid of all accompanying boilerplate then\r\nthis library could help you a bit.\r\n\r\nBackbone.ViewDSL provides a DSL built on top of HTML with the following\r\nfeatures:\r\n\r\n  * view instantiation (optionally loaded from AMD modules)\r\n  * conditional exclusion of DOM elements from a final result\r\n  * string and DOM node values interpolation\r\n\r\nThe basic example is to define a view which renders a chunk of HTML and instantiates\r\nsome sub-views:\r\n\r\n    class App extends Backbone.ViewDSL.View\r\n      template: \"\"\"\r\n        <h1>{{options.title}}</h1>\r\n        <view name=\"app.views.Sidebar\" id=\"sidebar\" />\r\n        <view name=\"app.views.Content\" id=\"content\" />\r\n        <div class=\"footer\">{{options.title}} by {{options.author}}</div>\r\n        \"\"\"\r\n\r\nThe code above is equivalent to the following piece of code written with \"raw\"\r\nBackbone abstractions:\r\n\r\n    class App extends Backbone.View\r\n      render: ->\r\n        this.$el.html \"\"\"\r\n          <h1>#{@options.title}</h1>\r\n          <div class=\"footer\">#{@options.title} by #{@options.author}</div>\r\n          \"\"\"\r\n        $title = this.$('h1')\r\n        this.content = new app.views.ContentView\r\n        this.content.render()\r\n        this.content.$el.after($title)\r\n        this.sidebar = new app.views.SidebarView\r\n        this.sidebar.render()\r\n        this.sidebar.$el.after($title)\r\n\r\nWhich is, I think, more verbose and mostly consist of boilerplate. Also\r\n`Backbone.ViewDSL.View` keeps track of instantiated views and handles its\r\ndisposal by removing all of them on a `remove()` call on parent view so you are\r\nsafe from memory leaks.\r\n\r\n## Installation\r\n\r\nYou can simply get [`backbone.viewdsl.js`][Backbone.ViewDSL] from the repository\r\nor use the repository as a submodule in your project. In that case you will need\r\nall the dependencies to be in place — [jQuery][jQuery], [Backbone][Backbone] and\r\n[RSVP.js][RSVP.js].\r\n\r\nOtherwise you can use awesome [bower][bower] package manager and install\r\nBackbone.ViewDSL with:\r\n\r\n    bower install backbone.viewdsl\r\n\r\nThis way you will have Backbone.ViewDSL and all the dependencies installed under\r\n`./components` directory.\r\n\r\n## Usage\r\n\r\nBackbone.ViewDSL provides a view base class with additional methods to use DSL\r\nfor DOM rendering. There are two ways to use it — the first one is an ad-hoc\r\nview creation with a `from(template)` static method:\r\n\r\n    sidebarPromise = Backbone.ViewDSL.View.from \"\"\"\r\n      <div class=\"sidebar\">\r\n        <ul class=\"sidebar-items\">\r\n          <li class=\"sidebar-item\">...</li>\r\n          ...\r\n        </ul>\r\n      </div>\r\n      \"\"\"\r\n\r\nThis way you get a `sidebarPromise`, a promise value which will resolve\r\nasynchronously in the future. The reason it returns a promise is because\r\nrendering process may require to load some additional resources using XHR (such\r\nas additional view classes). You can execute some code with a constructed view\r\nby attaching `then` callback to the promise:\r\n\r\n    sidebarPromise.then (sidebar) ->\r\n      console.log \"View constructed: #{sidebar}\"\r\n\r\nNote that the `div.sidebar` will become the root element, the `el` of the view.\r\n\r\nStatic method `from(template)` accepts HTML strings, DOM elements or jQuery\r\nelements as a `template` argument.\r\n\r\nAnother way to use `Backbone.ViewDSL.View` is to subclass it and use\r\n`renderDOM(template, localContext)` method for rendering DOM:\r\n\r\n    class SidebarView extends Backbone.ViewDSL.View\r\n      tagName: \"div\"\r\n      className: \"sidebar\"\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <ul class=\"sidebar-items\">\r\n            <li class=\"sidebar-item\">...</li>\r\n            ...\r\n          </ul>\r\n          \"\"\"\r\n\r\nThis way `renderDOM` method will also return a promise but the one which\r\nresolves to DOM node which is rendered from template. First argument `template`\r\ncan be a HTML string, DOM element or jQuery element. As a second argument\r\n`renderDOM` accepts an object which provides \"local\" values to template context\r\nso actual context's prototype chain looks like `localContext -> this`.\r\n\r\n`Backbone.ViewDSL.View` also provides default implementation of\r\n`render(localContext)` method which renders DOM from a template provided by\r\ninstance or prototype-level `template` attribute. In the latter case of\r\n`template` attribute being attached to prototype — `render` method caches its\r\nDOM representation not to parse template more than once when rendering multiple\r\nview instances. So the easiest way to define view is:\r\n\r\n    class SidebarView extends Backbone.ViewDSL.View\r\n      tagName: \"div\"\r\n      className: \"sidebar\"\r\n      template: \"\"\"\r\n        <ul class=\"sidebar-items\">\r\n          <li class=\"sidebar-item\">...</li>\r\n          ...\r\n        </ul>\r\n        \"\"\"\r\n\r\n## View instantiation\r\n\r\nThere are two ways you can instantiate views — using `<view />` tag or\r\nusing `view` DOM attribute on any DOM element.\r\n\r\n### Using `<view />` tag\r\n\r\nIf you use `<view />` tag then DOM element created by view will be used to\r\nreplace the `<view />` element in the resulting DOM, so the following code:\r\n\r\n    class myapp.views.SidebarView extends Backbone.View\r\n      className: 'sidebar'\r\n\r\n    Backbone.ViewDSL.View.from \"\"\"\r\n      <div>\r\n        <view name=\"myapp.views.SidebarView\" />\r\n      </div>\r\n      \"\"\"\r\n\r\nwill render a DOM like this:\r\n\r\n    <div>\r\n      <div class=\"sidebar\"></div>\r\n    </div>\r\n\r\nNote that `div.sidebar` element is created by `SidebarView` view. So usually it\r\nis a good idea to use `<view />` tag to instantiate views which can only\r\nfunction correctly with predefined `tagName` or `className` attributes.\r\n\r\nSee *Specs* section below to learn how to specify a view constructor in the\r\n`name` attribute.\r\n\r\n### Using `view` attribute\r\n\r\nIf you use `view` attribute on a DOM element then the DOM element will be passed\r\nas an `el` argument to a view constructor so all attributes on the DOM element\r\nsuch as `id` and `class` will be preserved. This example:\r\n\r\n    class myapp.views.ClickableLabel extends Backbone.View\r\n      className: 'sidebar'\r\n\r\n    Backbone.ViewDSL.View.from \"\"\"\r\n      <div>\r\n        <span view=\"myapp.views.ClickableLabel\" class=\"some-class\"></span>\r\n      </div>\r\n      \"\"\"\r\n\r\nwill result in the following DOM:\r\n\r\n    <div>\r\n      <span class=\"some-class\"></span>\r\n    </div>\r\n\r\nUsing `view` attribute for instantiating views is useful with those views which\r\ncan work with different configurations of `tagName` and/or `className`\r\narguments.\r\n\r\nSee *Specs* section below to learn how to specify a view constructor in the\r\n`view` attribute.\r\n\r\n### Accessing instantiated views\r\n\r\nSometimes you need to assign a specific view to an attribute of a parent\r\nview. You can do that with `view-id` attribute when you instantiate views using\r\n`view` attribute on a DOM element or with just an `id` attribute if you use\r\n`<view />` tag:\r\n\r\n    view = Backbone.ViewDSL.View.from \"\"\"\r\n      <view name=\"SomeView\" id=\"someView\" />\r\n      <div view=\"AnotherView\" id=\"anotherView></div>\r\n      \"\"\"\r\n    view.someView instanceof SomeView # true\r\n    view.anotherView instanceof AnotherView # true\r\n\r\nAlso all instantiated views are stored inside `views` attribute of a parent\r\nview.  This is useful because on a call to `remove()` method of a parent view we\r\ncan also call `remove()` method of every instantiated view — this way we can\r\nprevent \"zombie\" views to stay after we dispose a parent view. That's exactly\r\nthe way how `Backbone.ViewDSL.View.remove()` is implemented.\r\n\r\n### Passing arguments into view constructor\r\n\r\nYou can pass additional parameters into a view constructor. Consider the\r\nexample:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n      template: \"\"\"\r\n        <view name=\"Sidebar\" model=\"sidebarItems\" id=\"sidebar\" />\r\n        <ul view=\"Toolbar\"\r\n          view-id=\"toolbar\"\r\n          view-width=\"100\"\r\n          view-items=\"toolbarItems\"></ul>\r\n        \"\"\"\r\n\r\n      initialize: ->\r\n        this.toolbarItems = [\"create\", \"edit\", \"remove\"]\r\n\r\n      sidebarItems: ->\r\n        [\"links\", \"comments\"]\r\n\r\n    view = new MyView\r\n    view.render()\r\n    view.sidebar.options.model # [\"links\", \"comments\"]\r\n    view.toolbar.options.items # [\"create\", \"edit\", \"remove\"]\r\n    view.toolbar.options.width # \"100\"\r\n\r\nAs you can see, you use `view-` prefixed attributes if you instantiate views\r\nwith `view` attribute on a DOM element, otherwise, with `<view />` tag you just\r\nuse attributes without any prefix.\r\n\r\nParameter names are obtained by removing the `view-` prefix (only in case it was\r\nexist) from attribute names and then converting them to camelCase so\r\n`view-some-param` and `some-param` attribute names become `someParam` parameter\r\nname.\r\n\r\nParameters values are looked up on a parent view object using attribute values:\r\n\r\n  * If value is found — it is used for a parameter value (see `toolbarItems` in\r\n    the example above).\r\n  * If method is found — it is called and returned value is used for a parameter\r\n    value (see `sidebarItems` in the example above).\r\n  * If no method and no value is found — then just string attribute value is\r\n    used (see `view-width` attribute in the example above)\r\n\r\nNote, that `view-id` and `id` attributes are treated specially and are not\r\npassed to a view constructor (see *Accessing instantiated views* section above).\r\n\r\n### Inserting already instantiated views into DOM\r\n\r\nSometimes you don't need to instantiate view but instead want just to render and\r\ninsert a DOM element of an already instantiated view — the following example\r\nshows how to do that:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n      template: \"\"\"\r\n        <h1>Sidebar</h1>\r\n        <view name=\"@sidebarView\" />\r\n        <div view=\"@footerView\"></div>\r\n        \"\"\"\r\n\r\n      initialize: ->\r\n        this.sidebarView = new SidebarView\r\n        this.footerView = new FooterView\r\n\r\nWhen using `<view />` tag it is replaced with view's element `el` but when using\r\n`view` attribute on a DOM element a view's `setElement` method is called with\r\nthe corresponding DOM element.\r\n\r\nNote the special form of specs in `name` and `view` attributes which refers to\r\nobjects inside the context, e.g. inside the `MyView` instance.\r\n\r\n## String and DOM node values interpolation\r\n\r\nYou can insert arbitrary strings, DOM nodes or jQuery elements into template:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      name: ->\r\n        $ '<span class=\"name\">World</span>'\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div class=\"hello\">\r\n            Hello, {{name}}!\r\n          </div>\r\n          \"\"\"\r\n\r\nThis will render a `Hello, <span class=\"name\">World</span>` string inside\r\n`div.hello` element. Note that you can also return just a raw string from\r\n`name()` method — it will be converted to DOM `TextNode`; otherwise you can\r\nreturn any DOM object.\r\n\r\n## Conditional exclusion\r\n\r\nTo remove DOM nodes conditionally you can use `if` DOM attribute:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      showConditional: ->\r\n        this.options.showConditional\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div class=\"conditional\" if=\"showConditional\">\r\n            ...\r\n          </div>\r\n          \"\"\"\r\n\r\nElement `div.conditional` will be removed if `showConditional()` method evaluates\r\nto `false`. Note that you can also refer to view properties and not only methods\r\ninside `if` attributes.\r\n\r\n## Specs\r\n\r\nSpecs are strings which point to JS objects. They can point to some global\r\nobject, to some object inside a context (a view which renders a DOM) or\r\nto some object inside AMD module:\r\n\r\n  * `module1/module2:obj1.obj2` points to `obj2` inside `obj1` in\r\n    `module1/module2` AMD module.\r\n\r\n  * `obj1.obj2` points to `obj2` inside `obj1` inside `window` object\r\n\r\n  * `@obj` points to `obj` of a context (a view which renders a DOM)\r\n\r\n[jQuery]: http://jquery.com\r\n[Backbone]: http://backbonejs.org\r\n[RSVP.js]: https://github.com/tildeio/rsvp.js\r\n[Backbone.ViewDSL]: https://raw.github.com/andreypopp/backbone.viewdsl/master/backbone.viewdsl.js\r\n[bower]: http://twitter.github.com/bower/\r\n","google":"","name":"Backbone.ViewDSL","tagline":"DSL for defining Backbone.View hierarchies"}