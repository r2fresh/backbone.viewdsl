<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Backbone.ViewDSL by andreypopp</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Backbone.ViewDSL</h1>
        <p>DSL for defining Backbone.View hierarchies</p>

        <p class="view"><a href="https://github.com/andreypopp/backbone.viewdsl">View the Project on GitHub <small>andreypopp/backbone.viewdsl</small></a></p>


        <ul>
          <li><a href="https://github.com/andreypopp/backbone.viewdsl/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/andreypopp/backbone.viewdsl/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/andreypopp/backbone.viewdsl">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>Backbone.ViewDSL is a tiny library which provides a DSL for defining
Backbone.View hierarchies. If you are tired of manually composing views in your
Backbone application and want to get rid of all accompanying boilerplate then
this library could help you a bit.</p>

<p>Backbone.ViewDSL provides a DSL built on top of HTML with the following
features:</p>

<ul>
<li>view instantiation (optionally loaded from AMD modules)</li>
<li>conditional exclusion of DOM elements from a final result</li>
<li>string and DOM node values interpolation</li>
</ul><p>The basic example is to define a view which renders a chunk of HTML and instantiates
some sub-views:</p>

<pre><code>class App extends Backbone.ViewDSL.View
  template: """
    &lt;h1&gt;{{options.title}}&lt;/h1&gt;
    &lt;view name="app.views.Sidebar" id="sidebar" /&gt;
    &lt;view name="app.views.Content" id="content" /&gt;
    &lt;div class="footer"&gt;{{options.title}} by {{options.author}}&lt;/div&gt;
    """
</code></pre>

<p>The code above is equivalent to the following piece of code written with "raw"
Backbone abstractions:</p>

<pre><code>class App extends Backbone.View
  render: -&gt;
    this.$el.html """
      &lt;h1&gt;#{@options.title}&lt;/h1&gt;
      &lt;div class="footer"&gt;#{@options.title} by #{@options.author}&lt;/div&gt;
      """
    $title = this.$('h1')
    this.content = new app.views.ContentView
    this.content.render()
    this.content.$el.after($title)
    this.sidebar = new app.views.SidebarView
    this.sidebar.render()
    this.sidebar.$el.after($title)
</code></pre>

<p>Which is, I think, more verbose and mostly consist of boilerplate. Also
<code>Backbone.ViewDSL.View</code> keeps track of instantiated views and handles its
disposal by removing all of them on a <code>remove()</code> call on parent view so you are
safe from memory leaks.</p>

<h2>Installation</h2>

<p>You can simply get <a href="https://raw.github.com/andreypopp/backbone.viewdsl/master/backbone.viewdsl.js"><code>backbone.viewdsl.js</code></a> from the repository
or use the repository as a submodule in your project. In that case you will need
all the dependencies to be in place — <a href="http://jquery.com">jQuery</a>, <a href="http://backbonejs.org">Backbone</a> and
<a href="https://github.com/tildeio/rsvp.js">RSVP.js</a>.</p>

<p>Otherwise you can use awesome <a href="http://twitter.github.com/bower/">bower</a> package manager and install
Backbone.ViewDSL with:</p>

<pre><code>bower install backbone.viewdsl
</code></pre>

<p>This way you will have Backbone.ViewDSL and all the dependencies installed under
<code>./components</code> directory.</p>

<h2>Usage</h2>

<p>Backbone.ViewDSL provides a view base class with additional methods to use DSL
for DOM rendering. There are two ways to use it — the first one is an ad-hoc
view creation with a <code>from(template)</code> static method:</p>

<pre><code>sidebarPromise = Backbone.ViewDSL.View.from """
  &lt;div class="sidebar"&gt;
    &lt;ul class="sidebar-items"&gt;
      &lt;li class="sidebar-item"&gt;...&lt;/li&gt;
      ...
    &lt;/ul&gt;
  &lt;/div&gt;
  """
</code></pre>

<p>This way you get a <code>sidebarPromise</code>, a promise value which will resolve
asynchronously in the future. The reason it returns a promise is because
rendering process may require to load some additional resources using XHR (such
as additional view classes). You can execute some code with a constructed view
by attaching <code>then</code> callback to the promise:</p>

<pre><code>sidebarPromise.then (sidebar) -&gt;
  console.log "View constructed: #{sidebar}"
</code></pre>

<p>Note that the <code>div.sidebar</code> will become the root element, the <code>el</code> of the view.</p>

<p>Static method <code>from(template)</code> accepts HTML strings, DOM elements or jQuery
elements as a <code>template</code> argument.</p>

<p>Another way to use <code>Backbone.ViewDSL.View</code> is to subclass it and use
<code>renderDOM(template, localContext)</code> method for rendering DOM:</p>

<pre><code>class SidebarView extends Backbone.ViewDSL.View
  tagName: "div"
  className: "sidebar"
  render: -&gt;
    @renderDOM """
      &lt;ul class="sidebar-items"&gt;
        &lt;li class="sidebar-item"&gt;...&lt;/li&gt;
        ...
      &lt;/ul&gt;
      """
</code></pre>

<p>This way <code>renderDOM</code> method will also return a promise but the one which
resolves to DOM node which is rendered from template. First argument <code>template</code>
can be a HTML string, DOM element or jQuery element. As a second argument
<code>renderDOM</code> accepts an object which provides "local" values to template context
so actual context's prototype chain looks like <code>localContext -&gt; this</code>.</p>

<p><code>Backbone.ViewDSL.View</code> also provides default implementation of
<code>render(localContext)</code> method which renders DOM from a template provided by
instance or prototype-level <code>template</code> attribute. In the latter case of
<code>template</code> attribute being attached to prototype — <code>render</code> method caches its
DOM representation not to parse template more than once when rendering multiple
view instances. So the easiest way to define view is:</p>

<pre><code>class SidebarView extends Backbone.ViewDSL.View
  tagName: "div"
  className: "sidebar"
  template: """
    &lt;ul class="sidebar-items"&gt;
      &lt;li class="sidebar-item"&gt;...&lt;/li&gt;
      ...
    &lt;/ul&gt;
    """
</code></pre>

<h2>View instantiation</h2>

<p>There are two ways you can instantiate views — using <code>&lt;view /&gt;</code> tag or
using <code>view</code> DOM attribute on any DOM element.</p>

<h3>Using <code>&lt;view /&gt;</code> tag</h3>

<p>If you use <code>&lt;view /&gt;</code> tag then DOM element created by view will be used to
replace the <code>&lt;view /&gt;</code> element in the resulting DOM, so the following code:</p>

<pre><code>class myapp.views.SidebarView extends Backbone.View
  className: 'sidebar'

Backbone.ViewDSL.View.from """
  &lt;div&gt;
    &lt;view name="myapp.views.SidebarView" /&gt;
  &lt;/div&gt;
  """
</code></pre>

<p>will render a DOM like this:</p>

<pre><code>&lt;div&gt;
  &lt;div class="sidebar"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Note that <code>div.sidebar</code> element is created by <code>SidebarView</code> view. So usually it
is a good idea to use <code>&lt;view /&gt;</code> tag to instantiate views which can only
function correctly with predefined <code>tagName</code> or <code>className</code> attributes.</p>

<p>See <em>Specs</em> section below to learn how to specify a view constructor in the
<code>name</code> attribute.</p>

<h3>Using <code>view</code> attribute</h3>

<p>If you use <code>view</code> attribute on a DOM element then the DOM element will be passed
as an <code>el</code> argument to a view constructor so all attributes on the DOM element
such as <code>id</code> and <code>class</code> will be preserved. This example:</p>

<pre><code>class myapp.views.ClickableLabel extends Backbone.View
  className: 'sidebar'

Backbone.ViewDSL.View.from """
  &lt;div&gt;
    &lt;span view="myapp.views.ClickableLabel" class="some-class"&gt;&lt;/span&gt;
  &lt;/div&gt;
  """
</code></pre>

<p>will result in the following DOM:</p>

<pre><code>&lt;div&gt;
  &lt;span class="some-class"&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>

<p>Using <code>view</code> attribute for instantiating views is useful with those views which
can work with different configurations of <code>tagName</code> and/or <code>className</code>
arguments.</p>

<p>See <em>Specs</em> section below to learn how to specify a view constructor in the
<code>view</code> attribute.</p>

<h3>Accessing instantiated views</h3>

<p>Sometimes you need to assign a specific view to an attribute of a parent
view. You can do that with <code>view-id</code> attribute when you instantiate views using
<code>view</code> attribute on a DOM element or with just an <code>id</code> attribute if you use
<code>&lt;view /&gt;</code> tag:</p>

<pre><code>view = Backbone.ViewDSL.View.from """
  &lt;view name="SomeView" id="someView" /&gt;
  &lt;div view="AnotherView" id="anotherView&gt;&lt;/div&gt;
  """
view.someView instanceof SomeView # true
view.anotherView instanceof AnotherView # true
</code></pre>

<p>Also all instantiated views are stored inside <code>views</code> attribute of a parent
view.  This is useful because on a call to <code>remove()</code> method of a parent view we
can also call <code>remove()</code> method of every instantiated view — this way we can
prevent "zombie" views to stay after we dispose a parent view. That's exactly
the way how <code>Backbone.ViewDSL.View.remove()</code> is implemented.</p>

<h3>Passing arguments into view constructor</h3>

<p>You can pass additional parameters into a view constructor. Consider the
example:</p>

<pre><code>class MyView extends Backbone.ViewDSL.View
  template: """
    &lt;view name="Sidebar" model="sidebarItems" id="sidebar" /&gt;
    &lt;ul view="Toolbar"
      view-id="toolbar"
      view-width="100"
      view-items="toolbarItems"&gt;&lt;/ul&gt;
    """

  initialize: -&gt;
    this.toolbarItems = ["create", "edit", "remove"]

  sidebarItems: -&gt;
    ["links", "comments"]

view = new MyView
view.render()
view.sidebar.options.model # ["links", "comments"]
view.toolbar.options.items # ["create", "edit", "remove"]
view.toolbar.options.width # "100"
</code></pre>

<p>As you can see, you use <code>view-</code> prefixed attributes if you instantiate views
with <code>view</code> attribute on a DOM element, otherwise, with <code>&lt;view /&gt;</code> tag you just
use attributes without any prefix.</p>

<p>Parameter names are obtained by removing the <code>view-</code> prefix (only in case it was
exist) from attribute names and then converting them to camelCase so
<code>view-some-param</code> and <code>some-param</code> attribute names become <code>someParam</code> parameter
name.</p>

<p>Parameters values are looked up on a parent view object using attribute values:</p>

<ul>
<li>If value is found — it is used for a parameter value (see <code>toolbarItems</code> in
the example above).</li>
<li>If method is found — it is called and returned value is used for a parameter
value (see <code>sidebarItems</code> in the example above).</li>
<li>If no method and no value is found — then just string attribute value is
used (see <code>view-width</code> attribute in the example above)</li>
</ul><p>Note, that <code>view-id</code> and <code>id</code> attributes are treated specially and are not
passed to a view constructor (see <em>Accessing instantiated views</em> section above).</p>

<h3>Inserting already instantiated views into DOM</h3>

<p>Sometimes you don't need to instantiate view but instead want just to render and
insert a DOM element of an already instantiated view — the following example
shows how to do that:</p>

<pre><code>class MyView extends Backbone.ViewDSL.View
  template: """
    &lt;h1&gt;Sidebar&lt;/h1&gt;
    &lt;view name="@sidebarView" /&gt;
    &lt;div view="@footerView"&gt;&lt;/div&gt;
    """

  initialize: -&gt;
    this.sidebarView = new SidebarView
    this.footerView = new FooterView
</code></pre>

<p>When using <code>&lt;view /&gt;</code> tag it is replaced with view's element <code>el</code> but when using
<code>view</code> attribute on a DOM element a view's <code>setElement</code> method is called with
the corresponding DOM element.</p>

<p>Note the special form of specs in <code>name</code> and <code>view</code> attributes which refers to
objects inside the context, e.g. inside the <code>MyView</code> instance.</p>

<h2>String and DOM node values interpolation</h2>

<p>You can insert arbitrary strings, DOM nodes or jQuery elements into template:</p>

<pre><code>class MyView extends Backbone.ViewDSL.View

  name: -&gt;
    $ '&lt;span class="name"&gt;World&lt;/span&gt;'

  render: -&gt;
    @renderDOM """
      &lt;div class="hello"&gt;
        Hello, {{name}}!
      &lt;/div&gt;
      """
</code></pre>

<p>This will render a <code>Hello, &lt;span class="name"&gt;World&lt;/span&gt;</code> string inside
<code>div.hello</code> element. Note that you can also return just a raw string from
<code>name()</code> method — it will be converted to DOM <code>TextNode</code>; otherwise you can
return any DOM object.</p>

<h2>Conditional exclusion</h2>

<p>To remove DOM nodes conditionally you can use <code>if</code> DOM attribute:</p>

<pre><code>class MyView extends Backbone.ViewDSL.View

  showConditional: -&gt;
    this.options.showConditional

  render: -&gt;
    @renderDOM """
      &lt;div class="conditional" if="showConditional"&gt;
        ...
      &lt;/div&gt;
      """
</code></pre>

<p>Element <code>div.conditional</code> will be removed if <code>showConditional()</code> method evaluates
to <code>false</code>. Note that you can also refer to view properties and not only methods
inside <code>if</code> attributes.</p>

<h2>Specs</h2>

<p>Specs are strings which point to JS objects. They can point to some global
object, to some object inside a context (a view which renders a DOM) or
to some object inside AMD module:</p>

<ul>
<li><p><code>module1/module2:obj1.obj2</code> points to <code>obj2</code> inside <code>obj1</code> in
<code>module1/module2</code> AMD module.</p></li>
<li><p><code>obj1.obj2</code> points to <code>obj2</code> inside <code>obj1</code> inside <code>window</code> object</p></li>
<li><p><code>@obj</code> points to <code>obj</code> of a context (a view which renders a DOM)</p></li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/andreypopp">andreypopp</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>