{"name":"Backbone.ViewDSL","body":"Backbone.ViewDSL is a tiny library which provides a DSL for defining\r\nBackbone.View hierarchies. If you are tired of manually composing views in your\r\nBackbone application and want to get rid of all accompanying boilerplate then\r\nthis library could help a bit.\r\n\r\nBackbone.ViewDSL provides a DSL built on top of HTML with the following\r\nfeatures:\r\n\r\n  * view instantiation (optionally loaded from AMD modules)\r\n\r\n  * conditional exclusion of DOM elements from a final result\r\n\r\n  * string and DOM node values interpolation\r\n\r\n## Installation\r\n\r\nYou can simply get\r\n[`backbone.viewdsl.js`](https://raw.github.com/andreypopp/backbone.viewdsl/master/backbone.viewdsl.js)\r\nfrom the repository or use the repository as a submodule in your project. In\r\nthat case you will need all the dependencies to be in place —\r\n[jQuery](http://jquery.com), [Backbone](http://http://backbonejs.org) and\r\n[RSVP.js](https://github.com/tildeio/rsvp.js).\r\n\r\nOtherwise you can use awesome [bower](http://twitter.github.com/bower/) package\r\nmanager and install Backbone.ViewDSL with:\r\n\r\n    bower install backbone.viewdsl\r\n\r\nThis way you will have Backbone.ViewDSL and all the dependencies installed under\r\n`./components` directory.\r\n\r\n## Usage\r\n\r\nBackbone.ViewDSL provides a view base class with additional methods to use DSL\r\nfor DOM rendering. There are two ways to use it — the first one is an ad-hoc\r\nview creation with a `from` static method:\r\n\r\n    sidebarPromise = Backbone.ViewDSL.View.from \"\"\"\r\n      <div class=\"sidebar\">\r\n        <ul class=\"sidebar-items\">\r\n          <li class=\"sidebar-item\">...</li>\r\n          ...\r\n        </ul>\r\n      </div>\r\n      \"\"\"\r\n\r\nThis way you get a `sidebarPromise`, a promise value which will resolve\r\nasynchronously in the future. The reason it returns a promise is because\r\nrendering process may require to load some additional resources using XHR (such\r\nas additional view classes). You can execute some code with constructed view by\r\nattaching `then` callback to promise:\r\n\r\n    sidebarPromise.then (sidebar) ->\r\n      console.log \"View constructed: #{sidebar}\"\r\n\r\nNote that the `div.sidebar` will become the root element, the `el` of the view.\r\n\r\nAnother way to use `Backbone.ViewDSL.View` is to subclass it and use `renderDOM`\r\nmethod for rendering DOM:\r\n\r\n    class SidebarView extends Backbone.ViewDSL.View\r\n      tagName: \"div\"\r\n      className: \"sidebar\"\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <ul class=\"sidebar-items\">\r\n            <li class=\"sidebar-item\">...</li>\r\n            ...\r\n          </ul>\r\n          \"\"\"\r\n\r\nThis way `renderDOM` method will also return a promise but the one which\r\nresolves to DOM node which is rendered from template.\r\n\r\n## View instantiation\r\n\r\nTo instantiate view you can use `view` DOM attribute:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div view=\"myapp.views.SidebarView\" class=\"sidebar\"></div>\r\n          \"\"\"\r\n\r\nThis way `myapp.views.SidebarView` will be instantiated and rendered with `div.sidebar`\r\nelement as root element. All instantiated views become the \"child views\" of the\r\nparent views and stored inside `views` attribute — that means on parent's\r\n`remove()` call they are also being freed by calling `remove()`.\r\n\r\n## String and DOM node values interpolation\r\n\r\nYou can insert arbitrary strings, DOM nodes or jQuery elements into template:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      name: ->\r\n        $ '<span class=\"name\">World</span>'\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div class=\"hello\">\r\n            Hello, {{name}}!\r\n          </div>\r\n          \"\"\"\r\n\r\nThis will render a `Hello, <span class=\"name\">World</span>` string inside\r\n`div.hello` element. Note that you can also return just a raw string from\r\n`name()` method — it will be converted to DOM `TextNode`; otherwise you can\r\nreturn any DOM object.\r\n\r\n## Conditional exclusion\r\n\r\nTo remove DOM nodes conditionally you can use `if` DOM attribute:\r\n\r\n    class MyView extends Backbone.ViewDSL.View\r\n\r\n      showConditional: ->\r\n        this.options.showConditional\r\n\r\n      render: ->\r\n        @renderDOM \"\"\"\r\n          <div class=\"conditional\" if=\"showConditional\">\r\n            ...\r\n          </div>\r\n          \"\"\"\r\n\r\nElement `div.conditional` will be removed if `showConditional()` method evaluates\r\nto `false`. Note that you can also refer to view properties and not only methods\r\ninside `if` attributes.\r\n\r\n## Specs\r\n\r\nSpecs are strings which point to JS objects, specs can point to some global\r\nobject or to some object inside AMD module:\r\n\r\n  * `module1/module2:obj1.obj2` points to `obj2` inside `obj1` in\r\n    `module1/module2` AMD module.\r\n\r\n  * `obj1.obj2` points to `obj2` inside `obj1` inside `window` object\r\n","tagline":"DSL for defining Backbone.View hierarchies","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}